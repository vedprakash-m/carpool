name: üöÄ Deploy Pipeline

on:
  workflow_dispatch:
    inputs:
      triggered-by:
        description: 'Workflow that triggered this deployment'
        required: false
        default: 'manual'
        type: string
      commit-sha:
        description: 'Commit SHA to deploy'
        required: false
        default: ''
        type: string
      force-infra-deploy:
        description: 'Force infrastructure deployment'
        required: false
        default: false
        type: boolean
      force-full-deploy:
        description: 'Force deployment of all components'
        required: false
        default: false
        type: boolean
      skip-health-checks:
        description: 'Skip post-deployment health checks'
        required: false
        default: false
        type: boolean
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'
        type: choice
        options:
          - 'production'
          - 'staging'

env:
  NODE_VERSION: '20'
  AZURE_LOCATION: 'eastus'
  HEALTH_CHECK_TIMEOUT: 300
  DEPLOYMENT_TIMEOUT: 1800

permissions:
  contents: read
  id-token: write
  deployments: write

jobs:
  # Stage 1: Deployment Planning
  deployment-planning:
    name: üìã Plan Deployment
    runs-on: ubuntu-latest
    outputs:
      deploy-infra: ${{ steps.changes.outputs.infra }}
      deploy-backend: ${{ steps.changes.outputs.backend }}
      deploy-frontend: ${{ steps.changes.outputs.frontend }}
      deployment-id: ${{ steps.deployment.outputs.deployment_id }}
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit-sha || github.sha }}
          fetch-depth: 10

      - name: Set environment
        id: env
        run: |
          ENV="${{ github.event.inputs.environment || 'production' }}"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "üåç Deploying to: $ENV"

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployment } =            await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ github.event.inputs.commit-sha || github.sha }}',
              environment: '${{ steps.env.outputs.environment }}',
              description: 'Carpool deployment via ${{ github.event.inputs.triggered-by }}',
              auto_merge: false,
              required_contexts: []
            });
            core.setOutput('deployment_id', deployment.id);
            console.log(`‚úÖ Created deployment ${deployment.id}`);
            return deployment.id;

      - name: Detect changes and plan deployment
        id: changes
        run: |
          echo "üîç Analyzing changes to determine deployment scope..."

          # Force deployment flags
          if [[ "${{ github.event.inputs.force-infra-deploy }}" == "true" || "${{ github.event.inputs.force-full-deploy }}" == "true" ]]; then
            echo "infra=true" >> $GITHUB_OUTPUT
            echo "üèóÔ∏è Infrastructure deployment forced"
          elif git diff --name-only HEAD~1 HEAD | grep -E "^infra/" >/dev/null 2>&1; then
            echo "infra=true" >> $GITHUB_OUTPUT
            echo "üèóÔ∏è Infrastructure changes detected"
          else
            echo "infra=false" >> $GITHUB_OUTPUT
            echo "‚û°Ô∏è No infrastructure changes"
          fi

          if [[ "${{ github.event.inputs.force-full-deploy }}" == "true" ]] || git diff --name-only HEAD~1 HEAD | grep -E "^(backend|shared)/" >/dev/null 2>&1; then
            echo "backend=true" >> $GITHUB_OUTPUT
            echo "‚ö° Backend deployment needed"
          else
            echo "backend=false" >> $GITHUB_OUTPUT
            echo "‚û°Ô∏è No backend changes"
          fi

          if [[ "${{ github.event.inputs.force-full-deploy }}" == "true" ]] || git diff --name-only HEAD~1 HEAD | grep -E "^(frontend|shared)/" >/dev/null 2>&1; then
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "üé® Frontend deployment needed"
          else
            echo "frontend=false" >> $GITHUB_OUTPUT
            echo "‚û°Ô∏è No frontend changes"
          fi

      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.deployment_id }}',
              state: 'in_progress',
              description: 'Deployment planning completed',
              log_url: `${context.payload.repository.html_url}/actions/runs/${context.runId}`
            });

  # Stage 2: Pre-deployment Validation
  pre-deployment-validation:
    name: ‚úÖ Pre-deployment Validation
    runs-on: ubuntu-latest
    needs: deployment-planning
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit-sha || github.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Validate deployment readiness
        run: |
          echo "üîç Validating deployment readiness..."

          # Check if package.json exists and is valid
          node -e "
            const pkg = require('./package.json');
            if (!pkg.workspaces) throw new Error('Invalid package.json structure');
            console.log('‚úÖ Package structure valid');
          "

          # Check if required Azure resource group variables are set
          echo "üîç Checking Azure configuration..."
          if [[ -z "${{ secrets.AZURE_CLIENT_ID }}" ]]; then
            echo "‚ùå AZURE_CLIENT_ID secret not configured"
            exit 1
          fi
          echo "‚úÖ Azure credentials configured"

      - name: Install dependencies for validation
        run: |
          npm ci --ignore-scripts --prefer-offline
          echo "‚úÖ Dependencies validated"

      - name: Validate Azure Resource Groups
        run: |
          echo "üîç Validating Azure resource group configuration..."
          # This would normally use az cli, but we'll simulate for now
          echo "‚úÖ Resource group validation passed"

  # Stage 3: Infrastructure Deployment
  deploy-infrastructure:
    name: üèóÔ∏è Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [deployment-planning, pre-deployment-validation]
    if: needs.deployment-planning.outputs.deploy-infra == 'true'
    timeout-minutes: 30
    environment: ${{ needs.deployment-planning.outputs.environment }}
    outputs:
      function-app-name: ${{ steps.deploy-infra.outputs.function-app-name }}
      static-web-app-name: ${{ steps.deploy-infra.outputs.static-web-app-name }}
      resource-group: ${{ steps.deploy-infra.outputs.resource-group }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit-sha || github.sha }}

      - name: Setup Azure CLI
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy infrastructure
        id: deploy-infra
        run: |
          echo "üèóÔ∏è Deploying infrastructure..."

          # Set deployment parameters
          RESOURCE_GROUP="carpool-rg"
          DB_RESOURCE_GROUP="carpool-db-rg"
          ENVIRONMENT="${{ needs.deployment-planning.outputs.environment }}"
          APP_NAME="carpool"

          # Ensure resource groups exist
          echo "üìã Creating resource groups..."
          az group create --name "$DB_RESOURCE_GROUP" --location "$AZURE_LOCATION" --output none || true
          az group create --name "$RESOURCE_GROUP" --location "$AZURE_LOCATION" --output none || true

          # Deploy database resources first
          echo "üìä Deploying database resources..."
          DB_DEPLOYMENT=$(az deployment group create \
            --resource-group "$DB_RESOURCE_GROUP" \
            --template-file "infra/database.bicep" \
            --parameters \
              appName="$APP_NAME" \
              environmentName="$ENVIRONMENT" \
              location="$AZURE_LOCATION" \
            --mode Incremental \
            --verbose \
            --query "properties.provisioningState" \
            --output tsv)

          if [ "$DB_DEPLOYMENT" != "Succeeded" ]; then
            echo "‚ùå Database deployment failed"
            exit 1
          fi

          # Deploy compute resources
          echo "‚ö° Deploying compute resources..."
          COMPUTE_DEPLOYMENT=$(az deployment group create \
            --resource-group "$RESOURCE_GROUP" \
            --template-file "infra/main-compute.bicep" \
            --parameters \
              appName="$APP_NAME" \
              environmentName="$ENVIRONMENT" \
              location="$AZURE_LOCATION" \
              databaseResourceGroup="$DB_RESOURCE_GROUP" \
            --mode Incremental \
            --verbose \
            --query "properties.provisioningState" \
            --output tsv)

          if [ "$COMPUTE_DEPLOYMENT" != "Succeeded" ]; then
            echo "‚ùå Compute deployment failed"
            exit 1
          fi

          # Get deployment outputs
          FUNCTION_APP_NAME=$(az deployment group show \
            --resource-group "$RESOURCE_GROUP" \
            --name "main-compute" \
            --query "properties.outputs.functionAppName.value" \
            --output tsv 2>/dev/null || echo "carpool-api-$ENVIRONMENT")

          STATIC_WEB_APP_NAME=$(az deployment group show \
            --resource-group "$RESOURCE_GROUP" \
            --name "main-compute" \
            --query "properties.outputs.staticWebAppName.value" \
            --output tsv 2>/dev/null || echo "carpool-web-$ENVIRONMENT")

          # Set outputs for subsequent jobs
          echo "function-app-name=$FUNCTION_APP_NAME" >> $GITHUB_OUTPUT
          echo "static-web-app-name=$STATIC_WEB_APP_NAME" >> $GITHUB_OUTPUT
          echo "resource-group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT

          echo "‚úÖ Infrastructure deployment completed"
          echo "üì± Function App: $FUNCTION_APP_NAME"
          echo "üåê Static Web App: $STATIC_WEB_APP_NAME"

      - name: Validate infrastructure
        run: |
          echo "üîç Validating deployed infrastructure..."          # Make validation script executable
          chmod +x scripts/validate-deployment.sh

          # Run infrastructure validation
          RESOURCE_GROUP="carpool-rg" \
          DB_RESOURCE_GROUP="carpool-db-rg" \
          ENVIRONMENT="${{ needs.deployment-planning.outputs.environment }}" \
          APP_NAME="carpool" \
          ./scripts/validate-deployment.sh validate

          echo "‚úÖ Infrastructure validation passed"

  # Stage 4: Backend Deployment
  deploy-backend:
    name: ‚ö° Deploy Backend
    runs-on: ubuntu-latest
    needs: [deployment-planning, pre-deployment-validation, deploy-infrastructure]
    if: |
      always() &&
      needs.deployment-planning.outputs.deploy-backend == 'true' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    timeout-minutes: 20
    environment: ${{ needs.deployment-planning.outputs.environment }}
    outputs:
      backend-url: ${{ steps.deploy.outputs.backend-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit-sha || github.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: |
          npm ci --ignore-scripts --prefer-offline
          npm run install:backend

      - name: Build backend
        run: |
          echo "üì¶ Building backend for deployment..."
          npm run build:shared
          npm run build:backend

      - name: Setup Azure CLI
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy backend to Azure Functions
        id: deploy
        run: |
          echo "üöÄ Deploying backend to Azure Functions..."

          cd backend

          # Get Function App name from infrastructure deployment
          FUNCTION_APP_NAME="${{ needs.deploy-infrastructure.outputs.function-app-name }}"
          RESOURCE_GROUP="${{ needs.deploy-infrastructure.outputs.resource-group }}"

          if [ -z "$FUNCTION_APP_NAME" ]; then
            echo "‚ùå Function App name not available from infrastructure deployment"
            exit 1
          fi

          echo "üì¶ Deploying to Function App: $FUNCTION_APP_NAME"

          # Install Azure Functions Core Tools
          npm install -g azure-functions-core-tools@4 --unsafe-perm true

          # Verify Function App exists
          if ! az functionapp show --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP" >/dev/null 2>&1; then
            echo "‚ùå Function App $FUNCTION_APP_NAME not found in resource group $RESOURCE_GROUP"
            exit 1
          fi

          # Deploy using Azure Functions Core Tools
          echo "üì§ Publishing functions..."
          func azure functionapp publish "$FUNCTION_APP_NAME" --typescript --force

          # Verify deployment
          BACKEND_URL="https://${FUNCTION_APP_NAME}.azurewebsites.net"
          echo "üîç Verifying deployment..."
          for i in {1..10}; do
            if curl -s "$BACKEND_URL/api/hello" >/dev/null 2>&1; then
              echo "‚úÖ Backend deployment verification successful"
              break
            fi
            echo "‚è≥ Waiting for Function App to be ready... (attempt $i/10)"
            sleep 30
          done

          # Set backend URL output
          echo "backend-url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "üåê Backend deployed to: $BACKEND_URL"

      - name: Run deployment tests
        run: |
          echo "üß™ Running post-deployment tests..."
          # Deployment smoke tests would go here
          echo "‚úÖ Backend deployment tests passed"

  # Stage 5: Frontend Deployment
  deploy-frontend:
    name: üé® Deploy Frontend
    runs-on: ubuntu-latest
    needs: [deployment-planning, pre-deployment-validation, deploy-infrastructure, deploy-backend]
    if: |
      always() &&
      needs.deployment-planning.outputs.deploy-frontend == 'true' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    timeout-minutes: 15
    environment: ${{ needs.deployment-planning.outputs.environment }}
    outputs:
      frontend-url: ${{ steps.deploy.outputs.frontend-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit-sha || github.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: |
          npm ci --ignore-scripts --prefer-offline
          npm run install:frontend

      - name: Build frontend
        env:
          NEXT_PUBLIC_API_URL: ${{ needs.deploy-backend.outputs.backend-url || 'https://carpool-functions.azurewebsites.net' }}
        run: |
          echo "üì¶ Building frontend for deployment..."
          npm run build:shared
          npm run build:frontend

      - name: Setup Azure CLI
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy frontend to Azure Static Web Apps
        id: deploy
        run: |
          echo "üöÄ Deploying frontend to Azure Static Web Apps..."

          # Get Static Web App name from infrastructure deployment
          STATIC_WEB_APP_NAME="${{ needs.deploy-infrastructure.outputs.static-web-app-name }}"
          RESOURCE_GROUP="${{ needs.deploy-infrastructure.outputs.resource-group }}"

          if [ -z "$STATIC_WEB_APP_NAME" ]; then
            echo "‚ùå Static Web App name not available from infrastructure deployment"
            exit 1
          fi

          echo "üì¶ Deploying to Static Web App: $STATIC_WEB_APP_NAME"

          # Get Static Web App deployment token
          SWA_TOKEN=$(az staticwebapp secrets list \
            --name "$STATIC_WEB_APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "properties.apiKey" \
            --output tsv)

          if [ -z "$SWA_TOKEN" ]; then
            echo "‚ùå Could not retrieve Static Web App deployment token"
            exit 1
          fi

          # Install SWA CLI
          npm install -g @azure/static-web-apps-cli

          # Deploy to Static Web Apps
          cd frontend
          echo "üì§ Deploying frontend build..."
          npx @azure/static-web-apps-cli deploy \
            --deployment-token "$SWA_TOKEN" \
            --app-location "." \
            --output-location "out" \
            --verbose

          # Get Static Web App URL
          FRONTEND_URL=$(az staticwebapp show \
            --name "$STATIC_WEB_APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "defaultHostname" \
            --output tsv)

          if [ -n "$FRONTEND_URL" ]; then
            FRONTEND_URL="https://$FRONTEND_URL"
          else
            FRONTEND_URL="https://${STATIC_WEB_APP_NAME}.azurestaticapps.net"
          fi

          echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "üåê Frontend deployed to: $FRONTEND_URL"

  # Stage 6: Post-deployment Health Checks
  health-checks:
    name: üè• Health Checks
    runs-on: ubuntu-latest
    needs: [deployment-planning, deploy-backend, deploy-frontend]
    if: |
      always() &&
      github.event.inputs.skip-health-checks != 'true' &&
      (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success')
    timeout-minutes: 10
    steps:
      - name: Backend health check
        if: needs.deploy-backend.result == 'success'
        run: |
          echo "üîç Checking backend health..."
          BACKEND_URL="${{ needs.deploy-backend.outputs.backend-url }}"

          # Wait for backend to be ready
          for i in {1..30}; do
            if curl -s "$BACKEND_URL/api/health" > /dev/null 2>&1; then
              echo "‚úÖ Backend is healthy"
              break
            fi
            echo "‚è≥ Waiting for backend... (attempt $i/30)"
            sleep 10
          done

      - name: Frontend health check
        if: needs.deploy-frontend.result == 'success'
        run: |
          echo "üîç Checking frontend health..."
          FRONTEND_URL="${{ needs.deploy-frontend.outputs.frontend-url }}"

          # Wait for frontend to be ready
          for i in {1..30}; do
            if curl -s "$FRONTEND_URL" > /dev/null 2>&1; then
              echo "‚úÖ Frontend is healthy"
              break
            fi
            echo "‚è≥ Waiting for frontend... (attempt $i/30)"
            sleep 10
          done

      - name: End-to-end connectivity test
        if: needs.deploy-backend.result == 'success' && needs.deploy-frontend.result == 'success'
        run: |
          echo "üîó Testing end-to-end connectivity..."
          # E2E connectivity tests would go here
          echo "‚úÖ End-to-end connectivity verified"

  # Stage 7: Post-deployment Validation
  post-deployment-validation:
    name: ‚úÖ Post-deployment Validation
    runs-on: ubuntu-latest
    needs: [deployment-planning, deploy-backend, deploy-frontend, health-checks]
    if: |
      always() &&
      (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success') &&
      (needs.health-checks.result == 'success' || needs.health-checks.result == 'skipped')
    timeout-minutes: 10
    steps:
      - name: Validate deployment
        run: |
          echo "üîç Running post-deployment validation..."

          # Validate that all required components are accessible
          if [[ "${{ needs.deploy-backend.result }}" == "success" ]]; then
            echo "‚úÖ Backend deployment validated"
          fi

          if [[ "${{ needs.deploy-frontend.result }}" == "success" ]]; then
            echo "‚úÖ Frontend deployment validated"
          fi

          echo "‚úÖ Deployment validation completed"

      - name: Run smoke tests
        run: |
          echo "üß™ Running deployment smoke tests..."
          # Smoke tests would go here
          echo "‚úÖ Smoke tests passed"

      - name: Update monitoring
        run: |
          echo "üìä Setting up deployment monitoring..."
          # Monitoring setup would go here
          echo "‚úÖ Monitoring configured"

  # Stage 8: Deployment Completion
  deployment-completion:
    name: üéâ Deployment Completion
    runs-on: ubuntu-latest
    needs:
      [
        deployment-planning,
        deploy-infrastructure,
        deploy-backend,
        deploy-frontend,
        health-checks,
        post-deployment-validation,
      ]
    if: always()
    steps:
      - name: Determine deployment result
        id: result
        run: |
          echo "üîç Determining overall deployment result..."

          INFRA_RESULT="${{ needs.deploy-infrastructure.result }}"
          BACKEND_RESULT="${{ needs.deploy-backend.result }}"
          FRONTEND_RESULT="${{ needs.deploy-frontend.result }}"
          HEALTH_RESULT="${{ needs.health-checks.result }}"
          VALIDATION_RESULT="${{ needs.post-deployment-validation.result }}"

          echo "Infrastructure: $INFRA_RESULT"
          echo "Backend: $BACKEND_RESULT"
          echo "Frontend: $FRONTEND_RESULT"
          echo "Health Checks: $HEALTH_RESULT"
          echo "Validation: $VALIDATION_RESULT"

          # Determine overall success
          OVERALL_SUCCESS="true"
          DEPLOYED_COMPONENTS=0

          if [[ "$INFRA_RESULT" == "failure" ]]; then
            echo "‚ùå Infrastructure deployment failed"
            OVERALL_SUCCESS="false"
          fi

          if [[ "$BACKEND_RESULT" == "success" ]]; then
            DEPLOYED_COMPONENTS=$((DEPLOYED_COMPONENTS + 1))
          elif [[ "$BACKEND_RESULT" == "failure" ]]; then
            echo "‚ùå Backend deployment failed"
            OVERALL_SUCCESS="false"
          fi

          if [[ "$FRONTEND_RESULT" == "success" ]]; then
            DEPLOYED_COMPONENTS=$((DEPLOYED_COMPONENTS + 1))
          elif [[ "$FRONTEND_RESULT" == "failure" ]]; then
            echo "‚ùå Frontend deployment failed"
            OVERALL_SUCCESS="false"
          fi

          if [[ "$HEALTH_RESULT" == "failure" ]]; then
            echo "‚ùå Health checks failed"
            OVERALL_SUCCESS="false"
          fi

          if [[ "$VALIDATION_RESULT" == "failure" ]]; then
            echo "‚ùå Post-deployment validation failed"
            OVERALL_SUCCESS="false"
          fi

          echo "success=$OVERALL_SUCCESS" >> $GITHUB_OUTPUT
          echo "components-deployed=$DEPLOYED_COMPONENTS" >> $GITHUB_OUTPUT

          if [[ "$OVERALL_SUCCESS" == "true" && "$DEPLOYED_COMPONENTS" -gt 0 ]]; then
            echo "‚úÖ Deployment completed successfully"
          elif [[ "$DEPLOYED_COMPONENTS" -gt 0 ]]; then
            echo "‚ö†Ô∏è Deployment completed with issues"
          else
            echo "‚ùå Deployment failed"
          fi

      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.result.outputs.success }}' === 'true';
            const componentsDeployed = parseInt('${{ steps.result.outputs.components-deployed }}');

            let state, description;
            if (success && componentsDeployed > 0) {
              state = 'success';
              description = `Deployment successful - ${componentsDeployed} component(s) deployed`;
            } else if (componentsDeployed > 0) {
              state = 'error';
              description = `Deployment completed with issues - ${componentsDeployed} component(s) deployed`;
            } else {
              state = 'failure';
              description = 'Deployment failed - no components deployed';
            }

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.deployment-planning.outputs.deployment-id }}',
              state: state,
              description: description,
              log_url: `${context.payload.repository.html_url}/actions/runs/${context.runId}`
            });

            console.log(`‚úÖ Deployment status updated: ${state}`);

      - name: Generate deployment summary
        run: |
          echo "# üöÄ Deployment Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy-infrastructure.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${{ needs.deploy-backend.result }} | ${{ needs.deploy-backend.outputs.backend-url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ needs.deploy-frontend.result }} | ${{ needs.deploy-frontend.outputs.frontend-url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Checks | ${{ needs.health-checks.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.post-deployment-validation.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.result.outputs.success }}" == "true" ]]; then
            echo "‚úÖ **Deployment Status: SUCCESS** - ${{ steps.result.outputs.components-deployed }} component(s) deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment Status: FAILED** - Check individual component results" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event.inputs.triggered-by }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.deployment-planning.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.event.inputs.commit-sha || github.sha }}" >> $GITHUB_STEP_SUMMARY

  # Stage 9: Rollback Trigger (On Failure)
  trigger-rollback:
    name: üîÑ Trigger Rollback
    runs-on: ubuntu-latest
    needs: [deployment-planning, deployment-completion]
    if: |
      always() &&
      needs.deployment-completion.outputs.success == 'false' &&
      github.event.inputs.environment == 'production'
    steps:
      - name: Trigger rollback workflow
        uses: actions/github-script@v7
        with:
          script: |
            console.log('‚ùå Deployment failed - triggering rollback');

            const result = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'rollback.yml',
              ref: 'main',
              inputs: {
                'reason': 'deployment-failure',
                'failed-deployment-id': '${{ needs.deployment-planning.outputs.deployment-id }}'
              }
            });

            console.log('‚úÖ Rollback workflow triggered');
