import { HttpRequest } from '@azure/functions';
import DOMPurify from 'isomorphic-dompurify';
import { logger } from '../utils/logger';

/**
 * Input sanitization middleware to prevent XSS and injection attacks
 */
export class SanitizationMiddleware {
  private static readonly SUSPICIOUS_PATTERNS = [
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    /javascript:/gi,
    /on\w+\s*=/gi,
    /data:text\/html/gi,
    /vbscript:/gi,
    /expression\s*\(/gi,
    /@import/gi,
    /\$\{.*\}/g, // Template literal injection
    /\{\{.*\}\}/g, // Template injection
    /<iframe/gi,
    /<object/gi,
    /<embed/gi,
    /<link/gi,
    /<meta/gi,
    /<base/gi,
  ];

  private static readonly SQL_INJECTION_PATTERNS = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/gi,
    /('|(\\')|(;)|(\\';)|(\|\|)|(\/\*)|(\*\/)|(\-\-)|(\+)|(%)|(\bOR\b)|(\bAND\b))/gi,
    /(\b(CHAR|NCHAR|VARCHAR|NVARCHAR|TEXT|NTEXT|BINARY|VARBINARY|IMAGE)\b\s*\(\s*\d+\s*\))/gi,
    /(0x[0-9A-Fa-f]+)/g,
  ];

  private static readonly NOSQL_INJECTION_PATTERNS = [
    /\$where/gi,
    /\$ne/gi,
    /\$gt/gi,
    /\$lt/gi,
    /\$gte/gi,
    /\$lte/gi,
    /\$in/gi,
    /\$nin/gi,
    /\$regex/gi,
    /\$exists/gi,
    /\$elemMatch/gi,
    /\$all/gi,
    /\$size/gi,
  ];

  /**
   * Sanitizes a string value by removing potentially dangerous content
   */
  private static sanitizeString(value: string): string {
    if (typeof value !== 'string') {
      return value;
    }

    // Remove null bytes
    let sanitized = value.replace(/\0/g, '');

    // Trim whitespace
    sanitized = sanitized.trim();

    // Use DOMPurify to clean HTML content
    sanitized = DOMPurify.sanitize(sanitized, {
      ALLOWED_TAGS: [], // No HTML tags allowed
      ALLOWED_ATTR: [],
      KEEP_CONTENT: true,
    });

    // Additional custom sanitization
    sanitized = this.removeControlCharacters(sanitized);
    sanitized = this.normalizeWhitespace(sanitized);

    return sanitized;
  }

  /**
   * Removes control characters except tab, newline, and carriage return
   */
  private static removeControlCharacters(value: string): string {
    return value.replace(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F-\x9F]/g, '');
  }

  /**
   * Normalizes whitespace to prevent bypass attempts
   */
  private static normalizeWhitespace(value: string): string {
    return value.replace(/\s+/g, ' ').trim();
  }

  /**
   * Validates input against suspicious patterns
   */
  private static validateInput(value: string, fieldName: string): void {
    // Check for XSS patterns
    for (const pattern of this.SUSPICIOUS_PATTERNS) {
      if (pattern.test(value)) {
        logger.warn('Suspicious XSS pattern detected', {
          field: fieldName,
          pattern: pattern.source,
          value: value.substring(0, 100), // Log first 100 chars only
        });
        throw new Error(`Invalid input detected in field: ${fieldName}`);
      }
    }

    // Check for SQL injection patterns
    for (const pattern of this.SQL_INJECTION_PATTERNS) {
      if (pattern.test(value)) {
        logger.warn('Suspicious SQL injection pattern detected', {
          field: fieldName,
          pattern: pattern.source,
          value: value.substring(0, 100),
        });
        throw new Error(`Invalid input detected in field: ${fieldName}`);
      }
    }

    // Check for NoSQL injection patterns
    for (const pattern of this.NOSQL_INJECTION_PATTERNS) {
      if (pattern.test(value)) {
        logger.warn('Suspicious NoSQL injection pattern detected', {
          field: fieldName,
          pattern: pattern.source,
          value: value.substring(0, 100),
        });
        throw new Error(`Invalid input detected in field: ${fieldName}`);
      }
    }
  }

  /**
   * Recursively sanitizes an object
   */
  private static sanitizeObject(obj: any, path = ''): any {
    if (obj === null || obj === undefined) {
      return obj;
    }

    if (typeof obj === 'string') {
      const fieldPath = path || 'unknown';
      this.validateInput(obj, fieldPath);
      return this.sanitizeString(obj);
    }

    if (typeof obj === 'number' || typeof obj === 'boolean') {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map((item, index) => 
        this.sanitizeObject(item, `${path}[${index}]`)
      );
    }

    if (typeof obj === 'object') {
      const sanitized: any = {};
      for (const [key, value] of Object.entries(obj)) {
        const fieldPath = path ? `${path}.${key}` : key;
        
        // Sanitize the key itself
        const sanitizedKey = this.sanitizeString(key);
        this.validateInput(sanitizedKey, `${fieldPath}[key]`);
        
        // Sanitize the value
        sanitized[sanitizedKey] = this.sanitizeObject(value, fieldPath);
      }
      return sanitized;
    }

    return obj;
  }

  /**
   * Middleware function to sanitize request body and query parameters
   */
  static sanitizeRequest(request: HttpRequest): HttpRequest {
    try {
      // Sanitize query parameters
      if (request.query) {
        const sanitizedQuery: { [key: string]: string } = {};
        for (const [key, value] of Object.entries(request.query)) {
          if (typeof value === 'string') {
            this.validateInput(value, `query.${key}`);
            sanitizedQuery[this.sanitizeString(key)] = this.sanitizeString(value);
          }
        }
        request.query = sanitizedQuery;
      }

      // Sanitize request body
      if (request.body) {
        if (typeof request.body === 'string') {
          try {
            const parsed = JSON.parse(request.body);
            const sanitized = this.sanitizeObject(parsed);
            request.body = JSON.stringify(sanitized);
          } catch (error) {
            // If it's not JSON, treat as string
            this.validateInput(request.body, 'body');
            request.body = this.sanitizeString(request.body);
          }
        } else {
          request.body = this.sanitizeObject(request.body);
        }
      }

      // Sanitize headers (only specific ones we care about)
      if (request.headers) {
        const headersToSanitize = ['user-agent', 'referer', 'origin'];
        for (const headerName of headersToSanitize) {
          const headerValue = request.headers[headerName];
          if (typeof headerValue === 'string') {
            this.validateInput(headerValue, `header.${headerName}`);
            request.headers[headerName] = this.sanitizeString(headerValue);
          }
        }
      }

      logger.debug('Request sanitization completed successfully');
      return request;

    } catch (error) {
      logger.error('Request sanitization failed', { error: error.message });
      throw new Error('Invalid input detected in request');
    }
  }

  /**
   * Enhanced validation for specific field types
   */
  static validateSpecificFields(data: any): void {
    if (!data || typeof data !== 'object') {
      return;
    }

    // Email validation
    if (data.email && typeof data.email === 'string') {
      const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      if (!emailPattern.test(data.email)) {
        throw new Error('Invalid email format');
      }
      if (data.email.length > 254) {
        throw new Error('Email address too long');
      }
    }

    // Phone number validation
    if (data.phone && typeof data.phone === 'string') {
      const phonePattern = /^\+?[\d\s\-\(\)]{10,15}$/;
      if (!phonePattern.test(data.phone)) {
        throw new Error('Invalid phone number format');
      }
    }

    // URL validation
    const urlFields = ['website', 'profilePicture', 'avatar'];
    for (const field of urlFields) {
      if (data[field] && typeof data[field] === 'string') {
        try {
          const url = new URL(data[field]);
          if (!['http:', 'https:'].includes(url.protocol)) {
            throw new Error(`Invalid protocol for ${field}`);
          }
        } catch (error) {
          throw new Error(`Invalid URL format for ${field}`);
        }
      }
    }

    // Date validation
    const dateFields = ['startTime', 'endTime', 'departureTime', 'arrivalTime'];
    for (const field of dateFields) {
      if (data[field] && typeof data[field] === 'string') {
        const date = new Date(data[field]);
        if (isNaN(date.getTime())) {
          throw new Error(`Invalid date format for ${field}`);
        }
        // Prevent dates too far in the future (more than 2 years)
        const maxFutureDate = new Date();
        maxFutureDate.setFullYear(maxFutureDate.getFullYear() + 2);
        if (date > maxFutureDate) {
          throw new Error(`Date too far in the future for ${field}`);
        }
      }
    }

    // Numeric validation
    const numericFields = ['capacity', 'availableSeats', 'price'];
    for (const field of numericFields) {
      if (data[field] !== undefined) {
        const value = Number(data[field]);
        if (isNaN(value) || value < 0 || value > 10000) {
          throw new Error(`Invalid numeric value for ${field}`);
        }
      }
    }
  }
}
