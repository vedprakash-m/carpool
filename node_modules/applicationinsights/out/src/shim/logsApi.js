"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogApi = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const generated_1 = require("../declarations/generated");
const util_1 = require("../shared/util");
const exceptions_1 = require("../logs/exceptions");
/**
 * Log manual API to generate Application Insights telemetry
 */
class LogApi {
    /**
    * Constructs a new client of LogApi
    */
    constructor(logger) {
        this._idGenerator = new sdk_trace_base_1.RandomIdGenerator();
        this._logger = logger;
    }
    /**
       * Log information about availability of an application
       * @param telemetry      Object encapsulating tracking options
       */
    trackAvailability(telemetry) {
        try {
            const logRecord = this._availabilityToLogRecord(telemetry);
            this._logger.emit(logRecord);
        }
        catch (err) {
            api_1.diag.error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a page view
     * @param telemetry      Object encapsulating tracking options
     */
    trackPageView(telemetry) {
        try {
            const logRecord = this._pageViewToLogRecord(telemetry);
            this._logger.emit(logRecord);
        }
        catch (err) {
            api_1.diag.error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a trace message
     * @param telemetry      Object encapsulating tracking options
     */
    trackTrace(telemetry) {
        try {
            const logRecord = this._traceToLogRecord(telemetry);
            this._logger.emit(logRecord);
        }
        catch (err) {
            api_1.diag.error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log an exception
     * @param telemetry      Object encapsulating tracking options
     */
    trackException(telemetry) {
        if (telemetry && telemetry.exception && !util_1.Util.getInstance().isError(telemetry.exception)) {
            telemetry.exception = new Error(telemetry.exception.toString());
        }
        try {
            const logRecord = this._exceptionToLogRecord(telemetry);
            this._logger.emit(logRecord);
        }
        catch (err) {
            api_1.diag.error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a user action or other occurrence.
     * @param telemetry      Object encapsulating tracking options
     */
    trackEvent(telemetry) {
        try {
            const logRecord = this._eventToLogRecord(telemetry);
            this._logger.emit(logRecord);
        }
        catch (err) {
            api_1.diag.error("Failed to send telemetry.", err);
        }
    }
    _telemetryToLogRecord(telemetry, baseType, baseData) {
        try {
            const attributes = {};
            if (telemetry.properties) {
                for (const [key, value] of Object.entries(telemetry.properties)) {
                    // Serialize Error objects as strings to avoid serialization errors
                    if ((value === null || value === void 0 ? void 0 : value.constructor.name) === "Error") {
                        attributes[key] = util_1.Util.getInstance().stringify({
                            name: value.name,
                            message: value.message,
                            stack: value.stack,
                            cause: value.cause,
                        });
                    }
                    else {
                        attributes[key] = typeof value === 'object'
                            ? util_1.Util.getInstance().stringify(value)
                            : value;
                    }
                }
            }
            const record = { attributes: attributes, body: baseData };
            record.attributes["_MS.baseType"] = baseType;
            return record;
        }
        catch (err) {
            api_1.diag.warn("Failed to convert telemetry event to Log Record.", err);
        }
    }
    /**
    * Availability Log to LogRecord parsing.
    * @internal
    */
    _availabilityToLogRecord(telemetry) {
        const baseType = "AvailabilityData";
        const baseData = {
            id: telemetry.id || this._idGenerator.generateSpanId(),
            name: telemetry.name,
            duration: util_1.Util.getInstance().msToTimeSpan(telemetry.duration),
            success: telemetry.success,
            runLocation: telemetry.runLocation,
            message: telemetry.message,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * Exception to LogRecord parsing.
     * @internal
     */
    _exceptionToLogRecord(telemetry) {
        const baseType = "ExceptionData";
        const stack = telemetry.exception["stack"];
        const parsedStack = (0, exceptions_1.parseStack)(stack);
        const exceptionDetails = {
            message: telemetry.exception.message,
            typeName: telemetry.exception.name,
            parsedStack: parsedStack,
            hasFullStack: util_1.Util.getInstance().isArray(parsedStack) && parsedStack.length > 0,
        };
        const baseData = {
            severityLevel: telemetry.severity || generated_1.KnownSeverityLevel.Error,
            exceptions: [exceptionDetails],
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * Trace to LogRecord parsing.
     * @internal
     */
    _traceToLogRecord(telemetry) {
        const baseType = "MessageData";
        const baseData = {
            message: telemetry.message,
            severityLevel: telemetry.severity || generated_1.KnownSeverityLevel.Information,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * PageView to LogRecord parsing.
     * @internal
     */
    _pageViewToLogRecord(telemetry) {
        const baseType = "PageViewData";
        const baseData = {
            id: telemetry.id || this._idGenerator.generateSpanId(),
            name: telemetry.name,
            duration: util_1.Util.getInstance().msToTimeSpan(telemetry.duration),
            url: telemetry.url,
            referredUri: telemetry.referredUri,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * Event to LogRecord parsing.
     * @internal
     */
    _eventToLogRecord(telemetry) {
        const baseType = "EventData";
        const baseData = {
            name: telemetry.name,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
}
exports.LogApi = LogApi;
//# sourceMappingURL=logsApi.js.map