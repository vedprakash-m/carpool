"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.flushAzureMonitor = exports.shutdownAzureMonitor = exports.useAzureMonitor = void 0;
const monitor_opentelemetry_1 = require("@azure/monitor-opentelemetry");
const api_1 = require("@opentelemetry/api");
const api_logs_1 = require("@opentelemetry/api-logs");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const exporter_metrics_otlp_http_1 = require("@opentelemetry/exporter-metrics-otlp-http");
const exporter_logs_otlp_http_1 = require("@opentelemetry/exporter-logs-otlp-http");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const autoCollectLogs_1 = require("./logs/autoCollectLogs");
const exceptions_1 = require("./logs/exceptions");
const types_1 = require("./types");
const config_1 = require("./shared/configuration/config");
const logsApi_1 = require("./shim/logsApi");
const types_2 = require("./shim/types");
let autoCollectLogs;
let exceptions;
/**
 * Initialize Azure Monitor
 * @param options Configuration
 */
function useAzureMonitor(options) {
    // Must set statsbeat features before they are read by the distro
    process.env[types_1.AZURE_MONITOR_STATSBEAT_FEATURES] = JSON.stringify({
        instrumentation: types_2.StatsbeatInstrumentation.NONE,
        feature: types_2.StatsbeatFeature.SHIM
    });
    (0, monitor_opentelemetry_1.useAzureMonitor)(options);
    const internalConfig = new config_1.ApplicationInsightsConfig(options);
    const logApi = new logsApi_1.LogApi(api_logs_1.logs.getLogger("ApplicationInsightsLogger"));
    autoCollectLogs = new autoCollectLogs_1.AutoCollectLogs();
    if (internalConfig.enableAutoCollectExceptions) {
        exceptions = new exceptions_1.AutoCollectExceptions(logApi);
    }
    autoCollectLogs.enable(internalConfig.instrumentationOptions);
    _addOtlpExporters(internalConfig);
}
exports.useAzureMonitor = useAzureMonitor;
/**
* Shutdown Azure Monitor
*/
async function shutdownAzureMonitor() {
    await (0, monitor_opentelemetry_1.shutdownAzureMonitor)();
    autoCollectLogs.shutdown();
    exceptions === null || exceptions === void 0 ? void 0 : exceptions.shutdown();
}
exports.shutdownAzureMonitor = shutdownAzureMonitor;
/**
 *Try to send all queued telemetry if present.
 */
async function flushAzureMonitor() {
    try {
        await api_1.metrics.getMeterProvider().forceFlush();
        await (api_1.trace.getTracerProvider().getDelegate()).forceFlush();
        await api_logs_1.logs.getLoggerProvider().forceFlush();
    }
    catch (err) {
        api_1.diag.error("Failed to flush telemetry", err);
    }
}
exports.flushAzureMonitor = flushAzureMonitor;
function _addOtlpExporters(internalConfig) {
    var _a, _b, _c;
    if ((_a = internalConfig.otlpMetricExporterConfig) === null || _a === void 0 ? void 0 : _a.enabled) {
        const otlpMetricsExporter = new exporter_metrics_otlp_http_1.OTLPMetricExporter(internalConfig.otlpMetricExporterConfig);
        const otlpMetricReader = new sdk_metrics_1.PeriodicExportingMetricReader({
            exporter: otlpMetricsExporter,
        });
        try {
            api_1.metrics.getMeterProvider().addMetricReader(otlpMetricReader);
        }
        catch (err) {
            api_1.diag.error("Failed to set OTLP Metric Exporter", err);
        }
    }
    if ((_b = internalConfig.otlpLogExporterConfig) === null || _b === void 0 ? void 0 : _b.enabled) {
        const otlpLogExporter = new exporter_logs_otlp_http_1.OTLPLogExporter(internalConfig.otlpLogExporterConfig);
        const otlpLogProcessor = new sdk_logs_1.BatchLogRecordProcessor(otlpLogExporter);
        try {
            api_logs_1.logs.getLoggerProvider().addLogRecordProcessor(otlpLogProcessor);
        }
        catch (err) {
            api_1.diag.error("Failed to set OTLP Log Exporter", err);
        }
    }
    if ((_c = internalConfig.otlpTraceExporterConfig) === null || _c === void 0 ? void 0 : _c.enabled) {
        const otlpTraceExporter = new exporter_trace_otlp_http_1.OTLPTraceExporter(internalConfig.otlpTraceExporterConfig);
        const otlpSpanProcessor = new sdk_trace_node_1.BatchSpanProcessor(otlpTraceExporter);
        try {
            api_1.trace.getTracerProvider().getDelegate().addSpanProcessor(otlpSpanProcessor);
        }
        catch (err) {
            api_1.diag.error("Failed to set OTLP Trace Exporter", err);
        }
    }
}
//# sourceMappingURL=main.js.map