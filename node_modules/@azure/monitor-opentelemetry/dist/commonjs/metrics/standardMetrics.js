"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMetrics = void 0;
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const monitor_opentelemetry_exporter_1 = require("@azure/monitor-opentelemetry-exporter");
const api_1 = require("@opentelemetry/api");
const utils_js_1 = require("./utils.js");
const types_js_1 = require("./types.js");
/**
 * Azure Monitor Standard Metrics
 * @internal
 */
class StandardMetrics {
    /**
     * Initializes a new instance of the StandardMetrics class.
     * @param config - Distro configuration.
     * @param options - Standard Metrics options.
     */
    constructor(config, options) {
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        this._azureExporter = new monitor_opentelemetry_exporter_1.AzureMonitorMetricExporter(this._config.azureMonitorExporterOptions);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdk_metrics_1.PeriodicExportingMetricReader(metricReaderOptions);
        const meterProviderConfig = {
            resource: this._config.resource,
            readers: [this._metricReader],
        };
        this._meterProvider = new sdk_metrics_1.MeterProvider(meterProviderConfig);
        this._meter = this._meterProvider.getMeter("AzureMonitorStandardMetricsMeter");
        this._incomingRequestDurationHistogram = this._meter.createHistogram(types_js_1.StandardMetricIds.REQUEST_DURATION, {
            valueType: api_1.ValueType.DOUBLE,
        });
        this._outgoingRequestDurationHistogram = this._meter.createHistogram(types_js_1.StandardMetricIds.DEPENDENCIES_DURATION, {
            valueType: api_1.ValueType.DOUBLE,
        });
        this._exceptionsCounter = this._meter.createCounter(types_js_1.StandardMetricIds.EXCEPTIONS_COUNT, {
            valueType: api_1.ValueType.INT,
        });
        this._tracesCounter = this._meter.createCounter(types_js_1.StandardMetricIds.TRACES_COUNT, {
            valueType: api_1.ValueType.INT,
        });
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     * Add extra attributes to Span so Ingestion doesn't aggregate the data again
     * @internal
     */
    markSpanAsProcessed(span) {
        if (span.kind === api_1.SpanKind.CLIENT) {
            span.setAttributes({
                "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')",
            });
        }
        else if (span.kind === api_1.SpanKind.SERVER) {
            span.setAttributes({
                "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')",
            });
        }
    }
    /**
     * Record Span metrics
     * @internal
     */
    recordSpan(span) {
        const durationMs = span.duration[0];
        if (span.kind === api_1.SpanKind.SERVER) {
            this._incomingRequestDurationHistogram.record(durationMs, (0, utils_js_1.getRequestDimensions)(span));
        }
        else {
            this._outgoingRequestDurationHistogram.record(durationMs, (0, utils_js_1.getDependencyDimensions)(span));
        }
        if (span.events) {
            span.events.forEach((event) => {
                event.attributes = event.attributes || {};
                if (event.name === "exception") {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Exceptions', Ver:'1.1')";
                    this._exceptionsCounter.add(1, (0, utils_js_1.getExceptionDimensions)(span.resource));
                }
                else {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Traces', Ver:'1.1')";
                    this._tracesCounter.add(1, (0, utils_js_1.getTraceDimensions)(span.resource));
                }
            });
        }
    }
    /**
     * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion
     * @internal
     */
    recordLog(logRecord) {
        if ((0, utils_js_1.isSyntheticLoad)(logRecord)) {
            logRecord.setAttribute("operation/synthetic", "True");
        }
        if ((0, utils_js_1.isExceptionTelemetry)(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Exceptions', Ver:'1.1')");
            this._exceptionsCounter.add(1, (0, utils_js_1.getExceptionDimensions)(logRecord.resource));
        }
        else if ((0, utils_js_1.isTraceTelemetry)(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Traces', Ver:'1.1')");
            this._tracesCounter.add(1, (0, utils_js_1.getTraceDimensions)(logRecord.resource));
        }
    }
}
exports.StandardMetrics = StandardMetrics;
//# sourceMappingURL=standardMetrics.js.map