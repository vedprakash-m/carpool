{"version":3,"file":"projection.js","sourceRoot":"","sources":["../../../../../src/metrics/quickpulse/filtering/projection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { DerivedMetricInfo } from \"../../../generated/index.js\";\nimport { KnownAggregationType } from \"../../../generated/index.js\";\nimport type { TelemetryData } from \"../types.js\";\nimport { isRequestData, isDependencyData } from \"../utils.js\";\nimport { MetricFailureToCreateError } from \"./quickpulseErrors.js\";\n\nexport class Projection {\n  // contains the projections for all the derived metrics. key id, value [metric value, aggregation type]\n  private projectionMap: Map<string, [number, string]>;\n  // for calculation of avgs - key id, value [sum, count]\n  private avgMap: Map<string, [number, number]>;\n\n  constructor() {\n    this.projectionMap = new Map<string, [number, string]>();\n    this.avgMap = new Map<string, [number, number]>();\n  }\n\n  // This method is intended to be called upon configuration change for every valid derivedMetricInfo.\n  public initDerivedMetricProjection(derivedMetricInfo: DerivedMetricInfo): void {\n    if (derivedMetricInfo.aggregation === KnownAggregationType.Min.toString()) {\n      // set to max value so that the value from the first telemetry item will always be less than it\n      this.projectionMap.set(derivedMetricInfo.id, [Number.MAX_VALUE, KnownAggregationType.Min]);\n    } else if (derivedMetricInfo.aggregation === KnownAggregationType.Max.toString()) {\n      // set to min value so that the value from the first telemetry item will always be more than it\n      this.projectionMap.set(derivedMetricInfo.id, [Number.MIN_VALUE, KnownAggregationType.Max]);\n    } else if (derivedMetricInfo.aggregation === KnownAggregationType.Sum.toString()) {\n      this.projectionMap.set(derivedMetricInfo.id, [0, KnownAggregationType.Sum]);\n    } else {\n      this.projectionMap.set(derivedMetricInfo.id, [0, KnownAggregationType.Avg]);\n      this.avgMap.set(derivedMetricInfo.id, [0, 0]);\n    }\n  }\n\n  public calculateProjection(derivedMetricInfo: DerivedMetricInfo, data: TelemetryData): void {\n    let incrementBy: number;\n    if (derivedMetricInfo.projection === \"Count()\") {\n      incrementBy = 1;\n    } else if (derivedMetricInfo.projection === \"Duration\") {\n      if (isRequestData(data) || isDependencyData(data)) {\n        incrementBy = data.Duration;\n      } else {\n        throw new MetricFailureToCreateError(\n          \"The projection Duration is not supported for the telemetry type Exception or Trace.\",\n        );\n      }\n    } else if (derivedMetricInfo.projection.startsWith(\"CustomDimensions.\")) {\n      const customDimKey: string = derivedMetricInfo.projection.replace(\"CustomDimensions.\", \"\");\n      let customDimValue: number;\n      if (data.CustomDimensions.has(customDimKey)) {\n        const parsedValue = parseFloat(data.CustomDimensions.get(customDimKey) as string);\n        if (isNaN(parsedValue)) {\n          throw new MetricFailureToCreateError(\n            `Could not calculate the projection because the custom dimension value '${data.CustomDimensions.get(customDimKey)}' for the dimension '${customDimKey}' is not a valid number.`,\n          );\n        } else {\n          customDimValue = parsedValue;\n        }\n      } else {\n        throw new MetricFailureToCreateError(\n          `Could not calculate the projection because the custom dimension '${customDimKey}' was not found in the telemetry data.`,\n        );\n      }\n      incrementBy = customDimValue;\n    } else {\n      throw new MetricFailureToCreateError(\n        `The projection '${derivedMetricInfo.projection}' is not supported in this SDK.`,\n      );\n    }\n\n    const projection: number = this.calculateAggregation(\n      derivedMetricInfo.aggregation,\n      derivedMetricInfo.id,\n      incrementBy,\n    );\n    this.projectionMap.set(derivedMetricInfo.id, [projection, derivedMetricInfo.aggregation]);\n  }\n\n  // This method is intended to be called every second when export() is called.\n  public getMetricValues(): Map<string, number> {\n    const result: Map<string, number> = new Map();\n    for (const [key, value] of this.projectionMap.entries()) {\n      let projection: number;\n      if (value[1] === KnownAggregationType.Min.toString()) {\n        projection = value[0] === Number.MAX_VALUE ? 0 : value[0];\n        value[0] = Number.MAX_VALUE; // reset for next 1s interval\n      } else if (value[1] === KnownAggregationType.Max.toString()) {\n        projection = value[0] === Number.MIN_VALUE ? 0 : value[0];\n        value[0] = Number.MIN_VALUE; // reset for next 1s interval\n      } else {\n        projection = value[0];\n        value[0] = 0; // reset for next 1s interval\n        if (value[1] === KnownAggregationType.Avg.toString()) {\n          this.avgMap.set(key, [0, 0]); // reset for next 1s interval\n        }\n      }\n      result.set(key, projection);\n    }\n    return result;\n  }\n\n  // This method is intended to be called after upon config change or when we return to ping.\n  public clearProjectionMaps(): void {\n    this.projectionMap.clear();\n    this.avgMap.clear();\n  }\n\n  private calculateAggregation(aggregation: string, id: string, incrementBy: number): number {\n    const prevValue: number = (this.projectionMap.get(id) as [number, string])[0];\n    switch (aggregation) {\n      case KnownAggregationType.Sum.toString():\n        return prevValue + incrementBy;\n      case KnownAggregationType.Min.toString():\n        return Math.min(prevValue, incrementBy);\n      case KnownAggregationType.Max.toString():\n        return Math.max(prevValue, incrementBy);\n      case KnownAggregationType.Avg.toString(): {\n        const [prevSum, prevCount] = this.avgMap.get(id) as [number, number];\n        this.avgMap.set(id, [prevSum + incrementBy, prevCount + 1]);\n        return (prevSum + incrementBy) / (prevCount + 1);\n      }\n      default:\n        throw new MetricFailureToCreateError(\n          `The aggregation '${aggregation}' is not supported in this SDK.`,\n        );\n    }\n  }\n}\n"]}