"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filter = void 0;
const index_js_1 = require("../../../generated/index.js");
const types_js_1 = require("../types.js");
const utils_js_1 = require("../utils.js");
class Filter {
    renameExceptionFieldNamesForFiltering(filterConjunctionGroupInfo) {
        filterConjunctionGroupInfo.filters.forEach((filter) => {
            if (filter.fieldName.startsWith("Exception.")) {
                filter.fieldName = filter.fieldName.replace("Exception.", "");
            }
        });
    }
    checkMetricFilters(derivedMetricInfo, data) {
        if (derivedMetricInfo.filterGroups.length === 0) {
            // This should never happen - even when a user does not add filter pills to the derived metric,
            // the filterGroups array should have one filter group with an empty array of filters.
            return true;
        }
        // Haven't yet seen any case where there is more than one filter group in a derived metric info.
        // Just to be safe, handling the multiple filter conjunction group case as an or operation.
        let matched = false;
        derivedMetricInfo.filterGroups.forEach((filterConjunctionGroup) => {
            matched = matched || this.checkFilterConjunctionGroup(filterConjunctionGroup, data);
        });
        return matched;
    }
    checkFilterConjunctionGroup(filterConjunctionGroupInfo, data) {
        // All of the filters need to match for this to return true (and operation).
        for (const filter of filterConjunctionGroupInfo.filters) {
            if (!this.checkFilter(filter, data)) {
                return false;
            }
        }
        return true;
    }
    checkFilter(filter, data) {
        if (filter.fieldName === "*") {
            // Any field
            return this.checkAnyFieldFilter(filter, data);
        }
        else if (filter.fieldName.startsWith("CustomDimensions.")) {
            return this.checkCustomDimFilter(filter, data);
        }
        else {
            let dataValue;
            // use filter.fieldname to get the property of data to query
            if ((0, utils_js_1.isRequestData)(data)) {
                dataValue = data[filter.fieldName];
            }
            else if ((0, utils_js_1.isDependencyData)(data)) {
                dataValue = data[filter.fieldName];
            }
            else if ((0, utils_js_1.isExceptionData)(data)) {
                dataValue = data[filter.fieldName];
            }
            else if ((0, utils_js_1.isTraceData)(data)) {
                dataValue = data[filter.fieldName];
            }
            else {
                return false; // should not reach here
            }
            if (filter.fieldName === types_js_1.KnownRequestColumns.Success.toString()) {
                if (filter.predicate === index_js_1.KnownPredicateType.Equal.toString()) {
                    return dataValue === (filter.comparand.toLowerCase() === "true");
                }
                else if (filter.predicate === index_js_1.KnownPredicateType.NotEqual.toString()) {
                    return dataValue !== (filter.comparand.toLowerCase() === "true");
                }
            }
            else if (filter.fieldName === types_js_1.KnownDependencyColumns.ResultCode.toString() ||
                filter.fieldName === types_js_1.KnownRequestColumns.ResponseCode.toString() ||
                filter.fieldName === types_js_1.KnownDependencyColumns.Duration.toString()) {
                const comparand = filter.fieldName === types_js_1.KnownDependencyColumns.Duration.toString()
                    ? (0, utils_js_1.getMsFromFilterTimestampString)(filter.comparand)
                    : parseFloat(filter.comparand);
                switch (filter.predicate) {
                    case index_js_1.KnownPredicateType.Equal.toString():
                        return dataValue === comparand;
                    case index_js_1.KnownPredicateType.NotEqual.toString():
                        return dataValue !== comparand;
                    case index_js_1.KnownPredicateType.GreaterThan.toString():
                        return dataValue > comparand;
                    case index_js_1.KnownPredicateType.GreaterThanOrEqual.toString():
                        return dataValue >= comparand;
                    case index_js_1.KnownPredicateType.LessThan.toString():
                        return dataValue < comparand;
                    case index_js_1.KnownPredicateType.LessThanOrEqual.toString():
                        return dataValue <= comparand;
                    default:
                        return false;
                }
            }
            else {
                // string fields
                return this.stringCompare(dataValue, filter.comparand, filter.predicate);
            }
        }
        return false;
    }
    checkAnyFieldFilter(filter, data) {
        const properties = Object.keys(data);
        // At this point, the only predicates possible to pass in are Contains and DoesNotContain
        // At config validation time the predicate is checked to be one of these two.
        for (const property of properties) {
            if (property === "CustomDimensions") {
                for (const value of data.CustomDimensions.values()) {
                    if (this.stringCompare(value, filter.comparand, filter.predicate)) {
                        return true;
                    }
                }
            }
            else {
                // @ts-expect-error - data can be any type of telemetry data and we know property is a valid key
                const value = String(data[property]);
                if (this.stringCompare(value, filter.comparand, filter.predicate)) {
                    return true;
                }
            }
        }
        return false;
    }
    checkCustomDimFilter(filter, data) {
        const fieldName = filter.fieldName.replace("CustomDimensions.", "");
        let value;
        if (data.CustomDimensions.has(fieldName)) {
            value = data.CustomDimensions.get(fieldName);
        }
        else {
            return false; // the asked for field is not present in the custom dimensions
        }
        return this.stringCompare(value, filter.comparand, filter.predicate);
    }
    stringCompare(dataValue, comparand, predicate) {
        switch (predicate) {
            case index_js_1.KnownPredicateType.Equal.toString():
                return dataValue === comparand;
            case index_js_1.KnownPredicateType.NotEqual.toString():
                return dataValue !== comparand;
            case index_js_1.KnownPredicateType.Contains.toString(): {
                const lowerDataValue = dataValue.toLowerCase();
                const lowerComparand = comparand.toLowerCase();
                return lowerDataValue.includes(lowerComparand);
            }
            case index_js_1.KnownPredicateType.DoesNotContain.toString(): {
                const lowerDataValue = dataValue.toLowerCase();
                const lowerComparand = comparand.toLowerCase();
                return !lowerDataValue.includes(lowerComparand);
            }
            default:
                return false;
        }
    }
}
exports.Filter = Filter;
//# sourceMappingURL=filter.js.map