"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const quickpulseErrors_js_1 = require("./quickpulseErrors.js");
const types_js_1 = require("../types.js");
const index_js_1 = require("../../../generated/index.js");
const utils_js_1 = require("../utils.js");
const knownStringColumns = new Set([
    types_js_1.KnownRequestColumns.Url,
    types_js_1.KnownRequestColumns.Name,
    types_js_1.KnownDependencyColumns.Target,
    types_js_1.KnownDependencyColumns.Type,
    types_js_1.KnownDependencyColumns.Data,
    "Message",
    "Exception.Message",
    "Exception.StackTrace",
]);
class Validator {
    validateTelemetryType(telemetryType) {
        if (telemetryType === index_js_1.KnownTelemetryType.PerformanceCounter.toString()) {
            throw new quickpulseErrors_js_1.TelemetryTypeError("The telemetry type PerformanceCounter was specified, but this distro does not send performance counters to quickpulse.");
        }
        else if (telemetryType === index_js_1.KnownTelemetryType.Event.toString()) {
            throw new quickpulseErrors_js_1.TelemetryTypeError("The telemetry type Event was specified, but this telemetry type is not supported via OpenTelemetry.");
        }
        else if (telemetryType === index_js_1.KnownTelemetryType.Metric.toString()) {
            throw new quickpulseErrors_js_1.TelemetryTypeError("The telemetry type Metric was specified, but this distro does not send custom live metrics to quickpulse.");
        }
        else if (!(telemetryType in index_js_1.KnownTelemetryType)) {
            throw new quickpulseErrors_js_1.TelemetryTypeError(`'${telemetryType}' is not a valid telemetry type.`);
        }
    }
    checkCustomMetricProjection(derivedMetricInfo) {
        if (derivedMetricInfo.projection.startsWith("CustomMetrics.")) {
            throw new quickpulseErrors_js_1.UnexpectedFilterCreateError("The Projection of a customMetric property is not supported via OpenTelemetry.");
        }
    }
    validateMetricFilters(derivedMetricInfo) {
        derivedMetricInfo.filterGroups.forEach((filterGroup) => {
            filterGroup.filters.forEach((filter) => {
                this.validateFieldNames(filter.fieldName, derivedMetricInfo.telemetryType);
                this.validatePredicateAndComparand(filter);
            });
        });
    }
    validateDocumentFilters(documentFilterConjuctionGroupInfo) {
        const filterConjunctionGroupInfo = documentFilterConjuctionGroupInfo.filters;
        filterConjunctionGroupInfo.filters.forEach((filter) => {
            this.validateFieldNames(filter.fieldName, documentFilterConjuctionGroupInfo.telemetryType);
            this.validatePredicateAndComparand(filter);
        });
    }
    isCustomDimOrAnyField(fieldName) {
        return fieldName.startsWith("CustomDimensions.") || fieldName === "*";
    }
    validateFieldNames(fieldName, telemetryType) {
        if (fieldName === "") {
            throw new quickpulseErrors_js_1.UnexpectedFilterCreateError("A filter must have a field name.");
        }
        if (fieldName.startsWith("CustomMetrics.")) {
            throw new quickpulseErrors_js_1.UnexpectedFilterCreateError("Filtering of a customMetric property is not supported via OpenTelemetry.");
        }
        switch (telemetryType) {
            case index_js_1.KnownTelemetryType.Request.toString():
                if (!this.isCustomDimOrAnyField(fieldName) && !(fieldName in types_js_1.KnownRequestColumns)) {
                    throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Request.`);
                }
                break;
            case index_js_1.KnownTelemetryType.Dependency.toString():
                if (!this.isCustomDimOrAnyField(fieldName) && !(fieldName in types_js_1.KnownDependencyColumns)) {
                    throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Dependency.`);
                }
                break;
            case index_js_1.KnownTelemetryType.Exception.toString():
                if (!this.isCustomDimOrAnyField(fieldName) &&
                    fieldName !== "Exception.Message" &&
                    fieldName !== "Exception.StackTrace") {
                    throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Exception.`);
                }
                break;
            case index_js_1.KnownTelemetryType.Trace.toString():
                if (!this.isCustomDimOrAnyField(fieldName) && fieldName !== "Message") {
                    throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Trace.`);
                }
                break;
            default:
                throw new quickpulseErrors_js_1.TelemetryTypeError(`'${telemetryType}' is not a supported telemetry type.`);
        }
    }
    validatePredicateAndComparand(filter) {
        if (!(filter.predicate in index_js_1.KnownPredicateType)) {
            throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`'${filter.predicate}' is not a valid predicate.`);
        }
        else if (filter.comparand === "") {
            throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`A filter must have a comparand. FilterName: '${filter.fieldName}' Predicate: '${filter.predicate}' Comparand: '${filter.comparand}'`);
        }
        else if (filter.fieldName === "*" &&
            !(filter.predicate === index_js_1.KnownPredicateType.Contains.toString() ||
                filter.predicate === index_js_1.KnownPredicateType.DoesNotContain.toString())) {
            throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '*'`);
        }
        else if (filter.fieldName === types_js_1.KnownDependencyColumns.ResultCode.toString() ||
            filter.fieldName === types_js_1.KnownRequestColumns.ResponseCode.toString() ||
            filter.fieldName === types_js_1.KnownDependencyColumns.Duration.toString()) {
            if (filter.predicate === index_js_1.KnownPredicateType.Contains.toString() ||
                filter.predicate === index_js_1.KnownPredicateType.DoesNotContain.toString()) {
                throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '${filter.fieldName}'`);
            }
            // Duration comparand should be a timestamp; Response/ResultCode comparand should be interpreted as double.
            if (filter.fieldName === types_js_1.KnownDependencyColumns.Duration.toString()) {
                if (isNaN((0, utils_js_1.getMsFromFilterTimestampString)(filter.comparand))) {
                    throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The comparand '${filter.comparand}' can't be converted to a double (ms).`);
                }
            }
            else if (isNaN(parseFloat(filter.comparand))) {
                throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The comparand '${filter.comparand}' can't be converted to a double.`);
            }
        }
        else if (knownStringColumns.has(filter.fieldName) ||
            filter.fieldName.startsWith("CustomDimensions.")) {
            if (filter.predicate === index_js_1.KnownPredicateType.GreaterThan.toString() ||
                filter.predicate === index_js_1.KnownPredicateType.GreaterThanOrEqual.toString() ||
                filter.predicate === index_js_1.KnownPredicateType.LessThan.toString() ||
                filter.predicate === index_js_1.KnownPredicateType.LessThanOrEqual.toString()) {
                throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '${filter.fieldName}'. If this is a custom dimension, it would be treated as string.`);
            }
        }
        else if (filter.fieldName === types_js_1.KnownRequestColumns.Success.toString()) {
            if (filter.predicate !== index_js_1.KnownPredicateType.Equal.toString() &&
                filter.predicate !== index_js_1.KnownPredicateType.NotEqual.toString()) {
                throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '${filter.fieldName}'.`);
            }
            filter.comparand = filter.comparand.toLowerCase();
            if (filter.comparand !== "true" && filter.comparand !== "false") {
                throw new quickpulseErrors_js_1.UnexpectedFilterCreateError(`The comparand '${filter.comparand}' is not a valid boolean value for the fieldName Success.`);
            }
        }
    }
}
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map