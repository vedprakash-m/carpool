"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isContentTypeHeaderHtml = exports.insertBrowserSdkLoaderByIndex = exports.getContentEncodingFromHeaders = exports.isSupportedContentEncoding = exports.findBufferEncodingType = exports.isBufferType = exports.getBrotliDecompressSync = exports.getBrotliDecompressAsync = exports.getBrotliCompressSync = exports.getBrotliCompressAsync = exports.inflateAsync = exports.deflateAsync = exports.gunzipAsync = exports.gzipAsync = exports.isBrotliSupported = exports.bufferEncodingTypes = exports.contentEncodingMethod = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
const zlib = tslib_1.__importStar(require("zlib"));
const node_util_1 = require("node:util");
// currently support the following encoding types
var contentEncodingMethod;
(function (contentEncodingMethod) {
    contentEncodingMethod["GZIP"] = "gzip";
    contentEncodingMethod["DEFLATE"] = "deflate";
    contentEncodingMethod["BR"] = "br";
})(contentEncodingMethod || (exports.contentEncodingMethod = contentEncodingMethod = {}));
// current supported encoding types
exports.bufferEncodingTypes = [
    "utf8",
    "utf16le",
    "latin1",
    "base64",
    "hex",
    "ascii",
    "binary",
    "ucs2",
];
// for node version under 10, Brotli compression is not supported.
const isBrotliSupported = () => {
    const majVer = process.versions.node.split(".")[0];
    return parseInt(majVer) >= 10;
};
exports.isBrotliSupported = isBrotliSupported;
exports.gzipAsync = (0, node_util_1.promisify)(zlib.gzip);
exports.gunzipAsync = (0, node_util_1.promisify)(zlib.gunzip);
exports.deflateAsync = (0, node_util_1.promisify)(zlib.deflate);
exports.inflateAsync = (0, node_util_1.promisify)(zlib.inflate);
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const getBrotliCompressAsync = (zlibObject) => {
    const isMajorVer = (0, exports.isBrotliSupported)();
    if (isMajorVer && typeof zlibObject.brotliCompress === "function") {
        return (0, node_util_1.promisify)(zlibObject.brotliCompress);
    }
    return null;
};
exports.getBrotliCompressAsync = getBrotliCompressAsync;
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const getBrotliCompressSync = (zlibObject) => {
    const isMajorVer = (0, exports.isBrotliSupported)();
    if (isMajorVer && typeof zlibObject.brotliCompressSync === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return zlibObject.brotliCompressSync;
    }
    return null;
};
exports.getBrotliCompressSync = getBrotliCompressSync;
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const getBrotliDecompressAsync = (zlibObject) => {
    const isMajorVer = (0, exports.isBrotliSupported)();
    if (isMajorVer && typeof zlibObject.brotliDecompress === "function") {
        return (0, node_util_1.promisify)(zlibObject.brotliDecompress);
    }
    return null;
};
exports.getBrotliDecompressAsync = getBrotliDecompressAsync;
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const getBrotliDecompressSync = (zlibObject) => {
    const isMajorVer = (0, exports.isBrotliSupported)();
    if (isMajorVer && typeof zlibObject.brotliDecompressSync === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return zlibObject.brotliDecompressSync;
    }
    return null;
};
exports.getBrotliDecompressSync = getBrotliDecompressSync;
const isBufferType = (buffer, type) => {
    const encodingType = type ? type : "utf8";
    let result = false;
    if (Buffer.isEncoding(encodingType)) {
        const newBuffer = Buffer.from(buffer.toString(encodingType), encodingType);
        result = newBuffer.toJSON().data.toString() === buffer.toJSON().data.toString();
    }
    return result;
};
exports.isBufferType = isBufferType;
const findBufferEncodingType = (buffer) => {
    let bufferType = null;
    for (const type of exports.bufferEncodingTypes) {
        if (Buffer.isEncoding(type) && (0, exports.isBufferType)(buffer, type)) {
            bufferType = type;
            break;
        }
    }
    return bufferType;
};
exports.findBufferEncodingType = findBufferEncodingType;
const isSupportedContentEncoding = (encodingMethod) => {
    let encodingType = null;
    switch (encodingMethod) {
        case "gzip":
            encodingType = contentEncodingMethod.GZIP;
            break;
        case "br":
            encodingType = contentEncodingMethod.BR;
            break;
        case "deflate":
            encodingType = contentEncodingMethod.DEFLATE;
            break;
        default:
    }
    return encodingType;
};
exports.isSupportedContentEncoding = isSupportedContentEncoding;
// mutiple content-encoding is not supported
// for mutiple content-encoding, this method will return any empty array
const getContentEncodingFromHeaders = (response) => {
    const headers = [];
    const contentEncodingHeaders = response.getHeader("Content-Encoding");
    if (!contentEncodingHeaders)
        return null;
    if (typeof contentEncodingHeaders === "string") {
        const supportedContentEncoding = (0, exports.isSupportedContentEncoding)(contentEncodingHeaders);
        if (supportedContentEncoding) {
            headers.push(supportedContentEncoding);
        }
    }
    return headers;
};
exports.getContentEncodingFromHeaders = getContentEncodingFromHeaders;
const insertBrowserSdkLoaderByIndex = (index, html, snippet) => {
    if (index < 0)
        return null;
    let newHtml = null;
    const subStart = html.substring(0, index);
    const subEnd = html.substring(index);
    newHtml = subStart + '<script type="text/javascript">' + snippet + "</script>" + subEnd;
    return newHtml;
};
exports.insertBrowserSdkLoaderByIndex = insertBrowserSdkLoaderByIndex;
const isContentTypeHeaderHtml = (response) => {
    let isHtml = false;
    const contentType = response.getHeader("Content-Type");
    if (contentType) {
        if (typeof contentType === "string") {
            isHtml = contentType.indexOf("html") >= 0;
        }
        else {
            isHtml = contentType.toString().indexOf("html") >= 0;
        }
    }
    return isHtml;
};
exports.isContentTypeHeaderHtml = isContentTypeHeaderHtml;
//# sourceMappingURL=browserSdkLoaderHelper.js.map