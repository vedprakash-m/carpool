{"version":3,"file":"standardMetrics.js","sourceRoot":"","sources":["../../../src/metrics/standardMetrics.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  MeterProviderOptions,\n  PeriodicExportingMetricReaderOptions,\n} from \"@opentelemetry/sdk-metrics\";\nimport { MeterProvider, PeriodicExportingMetricReader } from \"@opentelemetry/sdk-metrics\";\nimport type { InternalConfig } from \"../shared/config.js\";\nimport { AzureMonitorMetricExporter } from \"@azure/monitor-opentelemetry-exporter\";\nimport type { Counter, Histogram, Meter } from \"@opentelemetry/api\";\nimport { SpanKind, ValueType } from \"@opentelemetry/api\";\nimport type { ReadableSpan, Span, TimedEvent } from \"@opentelemetry/sdk-trace-base\";\nimport type { LogRecord } from \"@opentelemetry/sdk-logs\";\nimport {\n  getDependencyDimensions,\n  getExceptionDimensions,\n  getRequestDimensions,\n  getTraceDimensions,\n  isExceptionTelemetry,\n  isSyntheticLoad,\n  isTraceTelemetry,\n} from \"./utils.js\";\nimport { StandardMetricIds } from \"./types.js\";\n\n/**\n * Azure Monitor Standard Metrics\n * @internal\n */\nexport class StandardMetrics {\n  private _config: InternalConfig;\n  private _collectionInterval = 60000; // 60 seconds\n  private _meterProvider: MeterProvider;\n  private _azureExporter: AzureMonitorMetricExporter;\n  private _metricReader: PeriodicExportingMetricReader;\n  private _meter: Meter;\n  private _incomingRequestDurationHistogram: Histogram;\n  private _outgoingRequestDurationHistogram: Histogram;\n  private _exceptionsCounter: Counter;\n  private _tracesCounter: Counter;\n\n  /**\n   * Initializes a new instance of the StandardMetrics class.\n   * @param config - Distro configuration.\n   * @param options - Standard Metrics options.\n   */\n  constructor(config: InternalConfig, options?: { collectionInterval: number }) {\n    this._config = config;\n    this._azureExporter = new AzureMonitorMetricExporter(this._config.azureMonitorExporterOptions);\n    const metricReaderOptions: PeriodicExportingMetricReaderOptions = {\n      exporter: this._azureExporter as any,\n      exportIntervalMillis: options?.collectionInterval || this._collectionInterval,\n    };\n    this._metricReader = new PeriodicExportingMetricReader(metricReaderOptions);\n    const meterProviderConfig: MeterProviderOptions = {\n      resource: this._config.resource,\n      readers: [this._metricReader],\n    };\n    this._meterProvider = new MeterProvider(meterProviderConfig);\n    this._meter = this._meterProvider.getMeter(\"AzureMonitorStandardMetricsMeter\");\n    this._incomingRequestDurationHistogram = this._meter.createHistogram(\n      StandardMetricIds.REQUEST_DURATION,\n      {\n        valueType: ValueType.DOUBLE,\n      },\n    );\n    this._outgoingRequestDurationHistogram = this._meter.createHistogram(\n      StandardMetricIds.DEPENDENCIES_DURATION,\n      {\n        valueType: ValueType.DOUBLE,\n      },\n    );\n\n    this._exceptionsCounter = this._meter.createCounter(StandardMetricIds.EXCEPTIONS_COUNT, {\n      valueType: ValueType.INT,\n    });\n    this._tracesCounter = this._meter.createCounter(StandardMetricIds.TRACES_COUNT, {\n      valueType: ValueType.INT,\n    });\n  }\n\n  /**\n   * Shutdown Meter Provider it will return no-op Meters after being called.\n   */\n  public shutdown(): void {\n    this._meterProvider.shutdown();\n  }\n\n  /**\n   * Force flush Meter Provider.\n   */\n  public async flush(): Promise<void> {\n    await this._meterProvider.forceFlush();\n  }\n\n  /**\n   *Get OpenTelemetry MeterProvider\n   */\n  public getMeterProvider(): MeterProvider {\n    return this._meterProvider;\n  }\n\n  /**\n   * Add extra attributes to Span so Ingestion doesn't aggregate the data again\n   * @internal\n   */\n  public markSpanAsProcessed(span: Span): void {\n    if (span.kind === SpanKind.CLIENT) {\n      span.setAttributes({\n        \"_MS.ProcessedByMetricExtractors\": \"(Name:'Dependencies', Ver:'1.1')\",\n      });\n    } else if (span.kind === SpanKind.SERVER) {\n      span.setAttributes({\n        \"_MS.ProcessedByMetricExtractors\": \"(Name:'Requests', Ver:'1.1')\",\n      });\n    }\n  }\n\n  /**\n   * Record Span metrics\n   * @internal\n   */\n  public recordSpan(span: ReadableSpan): void {\n    const durationMs = span.duration[0];\n    if (span.kind === SpanKind.SERVER) {\n      this._incomingRequestDurationHistogram.record(durationMs, getRequestDimensions(span));\n    } else {\n      this._outgoingRequestDurationHistogram.record(durationMs, getDependencyDimensions(span));\n    }\n    if (span.events) {\n      span.events.forEach((event: TimedEvent) => {\n        event.attributes = event.attributes || {};\n        if (event.name === \"exception\") {\n          event.attributes[\"_MS.ProcessedByMetricExtractors\"] = \"(Name:'Exceptions', Ver:'1.1')\";\n          this._exceptionsCounter.add(1, getExceptionDimensions(span.resource));\n        } else {\n          event.attributes[\"_MS.ProcessedByMetricExtractors\"] = \"(Name:'Traces', Ver:'1.1')\";\n          this._tracesCounter.add(1, getTraceDimensions(span.resource));\n        }\n      });\n    }\n  }\n\n  /**\n   * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion\n   * @internal\n   */\n  public recordLog(logRecord: LogRecord): void {\n    if (isSyntheticLoad(logRecord)) {\n      logRecord.setAttribute(\"operation/synthetic\", \"True\");\n    }\n    if (isExceptionTelemetry(logRecord)) {\n      logRecord.setAttribute(\"_MS.ProcessedByMetricExtractors\", \"(Name:'Exceptions', Ver:'1.1')\");\n      this._exceptionsCounter.add(1, getExceptionDimensions(logRecord.resource));\n    } else if (isTraceTelemetry(logRecord)) {\n      logRecord.setAttribute(\"_MS.ProcessedByMetricExtractors\", \"(Name:'Traces', Ver:'1.1')\");\n      this._tracesCounter.add(1, getTraceDimensions(logRecord.resource));\n    }\n  }\n}\n"]}