// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { MeterProvider, PeriodicExportingMetricReader } from "@opentelemetry/sdk-metrics";
import { AzureMonitorMetricExporter } from "@azure/monitor-opentelemetry-exporter";
import { SpanKind, ValueType } from "@opentelemetry/api";
import { getDependencyDimensions, getExceptionDimensions, getRequestDimensions, getTraceDimensions, isExceptionTelemetry, isSyntheticLoad, isTraceTelemetry, } from "./utils.js";
import { StandardMetricIds } from "./types.js";
/**
 * Azure Monitor Standard Metrics
 * @internal
 */
export class StandardMetrics {
    /**
     * Initializes a new instance of the StandardMetrics class.
     * @param config - Distro configuration.
     * @param options - Standard Metrics options.
     */
    constructor(config, options) {
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        this._azureExporter = new AzureMonitorMetricExporter(this._config.azureMonitorExporterOptions);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new PeriodicExportingMetricReader(metricReaderOptions);
        const meterProviderConfig = {
            resource: this._config.resource,
            readers: [this._metricReader],
        };
        this._meterProvider = new MeterProvider(meterProviderConfig);
        this._meter = this._meterProvider.getMeter("AzureMonitorStandardMetricsMeter");
        this._incomingRequestDurationHistogram = this._meter.createHistogram(StandardMetricIds.REQUEST_DURATION, {
            valueType: ValueType.DOUBLE,
        });
        this._outgoingRequestDurationHistogram = this._meter.createHistogram(StandardMetricIds.DEPENDENCIES_DURATION, {
            valueType: ValueType.DOUBLE,
        });
        this._exceptionsCounter = this._meter.createCounter(StandardMetricIds.EXCEPTIONS_COUNT, {
            valueType: ValueType.INT,
        });
        this._tracesCounter = this._meter.createCounter(StandardMetricIds.TRACES_COUNT, {
            valueType: ValueType.INT,
        });
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     * Add extra attributes to Span so Ingestion doesn't aggregate the data again
     * @internal
     */
    markSpanAsProcessed(span) {
        if (span.kind === SpanKind.CLIENT) {
            span.setAttributes({
                "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')",
            });
        }
        else if (span.kind === SpanKind.SERVER) {
            span.setAttributes({
                "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')",
            });
        }
    }
    /**
     * Record Span metrics
     * @internal
     */
    recordSpan(span) {
        const durationMs = span.duration[0];
        if (span.kind === SpanKind.SERVER) {
            this._incomingRequestDurationHistogram.record(durationMs, getRequestDimensions(span));
        }
        else {
            this._outgoingRequestDurationHistogram.record(durationMs, getDependencyDimensions(span));
        }
        if (span.events) {
            span.events.forEach((event) => {
                event.attributes = event.attributes || {};
                if (event.name === "exception") {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Exceptions', Ver:'1.1')";
                    this._exceptionsCounter.add(1, getExceptionDimensions(span.resource));
                }
                else {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Traces', Ver:'1.1')";
                    this._tracesCounter.add(1, getTraceDimensions(span.resource));
                }
            });
        }
    }
    /**
     * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion
     * @internal
     */
    recordLog(logRecord) {
        if (isSyntheticLoad(logRecord)) {
            logRecord.setAttribute("operation/synthetic", "True");
        }
        if (isExceptionTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Exceptions', Ver:'1.1')");
            this._exceptionsCounter.add(1, getExceptionDimensions(logRecord.resource));
        }
        else if (isTraceTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Traces', Ver:'1.1')");
            this._tracesCounter.add(1, getTraceDimensions(logRecord.resource));
        }
    }
}
//# sourceMappingURL=standardMetrics.js.map