{"version":3,"file":"filter.js","sourceRoot":"","sources":["../../../../../src/metrics/quickpulse/filtering/filter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  DerivedMetricInfo,\n  FilterInfo,\n  FilterConjunctionGroupInfo,\n} from \"../../../generated/index.js\";\nimport { KnownPredicateType } from \"../../../generated/index.js\";\nimport type {\n  RequestData,\n  TelemetryData,\n  DependencyData,\n  ExceptionData,\n  TraceData,\n} from \"../types.js\";\nimport { KnownDependencyColumns, KnownRequestColumns } from \"../types.js\";\nimport {\n  isRequestData,\n  isDependencyData,\n  isExceptionData,\n  isTraceData,\n  getMsFromFilterTimestampString,\n} from \"../utils.js\";\n\nexport class Filter {\n  public renameExceptionFieldNamesForFiltering(\n    filterConjunctionGroupInfo: FilterConjunctionGroupInfo,\n  ): void {\n    filterConjunctionGroupInfo.filters.forEach((filter) => {\n      if (filter.fieldName.startsWith(\"Exception.\")) {\n        filter.fieldName = filter.fieldName.replace(\"Exception.\", \"\");\n      }\n    });\n  }\n\n  public checkMetricFilters(derivedMetricInfo: DerivedMetricInfo, data: TelemetryData): boolean {\n    if (derivedMetricInfo.filterGroups.length === 0) {\n      // This should never happen - even when a user does not add filter pills to the derived metric,\n      // the filterGroups array should have one filter group with an empty array of filters.\n      return true;\n    }\n    // Haven't yet seen any case where there is more than one filter group in a derived metric info.\n    // Just to be safe, handling the multiple filter conjunction group case as an or operation.\n    let matched = false;\n    derivedMetricInfo.filterGroups.forEach((filterConjunctionGroup) => {\n      matched = matched || this.checkFilterConjunctionGroup(filterConjunctionGroup, data);\n    });\n    return matched;\n  }\n\n  public checkFilterConjunctionGroup(\n    filterConjunctionGroupInfo: FilterConjunctionGroupInfo,\n    data: TelemetryData,\n  ): boolean {\n    // All of the filters need to match for this to return true (and operation).\n    for (const filter of filterConjunctionGroupInfo.filters) {\n      if (!this.checkFilter(filter, data)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private checkFilter(filter: FilterInfo, data: TelemetryData): boolean {\n    if (filter.fieldName === \"*\") {\n      // Any field\n      return this.checkAnyFieldFilter(filter, data);\n    } else if (filter.fieldName.startsWith(\"CustomDimensions.\")) {\n      return this.checkCustomDimFilter(filter, data);\n    } else {\n      let dataValue: string | number | boolean | Map<string, string>;\n      // use filter.fieldname to get the property of data to query\n      if (isRequestData(data)) {\n        dataValue = data[filter.fieldName as keyof RequestData];\n      } else if (isDependencyData(data)) {\n        dataValue = data[filter.fieldName as keyof DependencyData];\n      } else if (isExceptionData(data)) {\n        dataValue = data[filter.fieldName as keyof ExceptionData];\n      } else if (isTraceData(data)) {\n        dataValue = data[filter.fieldName as keyof TraceData];\n      } else {\n        return false; // should not reach here\n      }\n\n      if (filter.fieldName === KnownRequestColumns.Success.toString()) {\n        if (filter.predicate === KnownPredicateType.Equal.toString()) {\n          return dataValue === (filter.comparand.toLowerCase() === \"true\");\n        } else if (filter.predicate === KnownPredicateType.NotEqual.toString()) {\n          return dataValue !== (filter.comparand.toLowerCase() === \"true\");\n        }\n      } else if (\n        filter.fieldName === KnownDependencyColumns.ResultCode.toString() ||\n        filter.fieldName === KnownRequestColumns.ResponseCode.toString() ||\n        filter.fieldName === KnownDependencyColumns.Duration.toString()\n      ) {\n        const comparand: number =\n          filter.fieldName === KnownDependencyColumns.Duration.toString()\n            ? getMsFromFilterTimestampString(filter.comparand)\n            : parseFloat(filter.comparand);\n        switch (filter.predicate) {\n          case KnownPredicateType.Equal.toString():\n            return dataValue === comparand;\n          case KnownPredicateType.NotEqual.toString():\n            return dataValue !== comparand;\n          case KnownPredicateType.GreaterThan.toString():\n            return (dataValue as number) > comparand;\n          case KnownPredicateType.GreaterThanOrEqual.toString():\n            return (dataValue as number) >= comparand;\n          case KnownPredicateType.LessThan.toString():\n            return (dataValue as number) < comparand;\n          case KnownPredicateType.LessThanOrEqual.toString():\n            return (dataValue as number) <= comparand;\n          default:\n            return false;\n        }\n      } else {\n        // string fields\n        return this.stringCompare(dataValue as string, filter.comparand, filter.predicate);\n      }\n    }\n    return false;\n  }\n\n  private checkAnyFieldFilter(filter: FilterInfo, data: TelemetryData): boolean {\n    const properties: string[] = Object.keys(data);\n    // At this point, the only predicates possible to pass in are Contains and DoesNotContain\n    // At config validation time the predicate is checked to be one of these two.\n    for (const property of properties) {\n      if (property === \"CustomDimensions\") {\n        for (const value of data.CustomDimensions.values()) {\n          if (this.stringCompare(value, filter.comparand, filter.predicate)) {\n            return true;\n          }\n        }\n      } else {\n        // @ts-expect-error - data can be any type of telemetry data and we know property is a valid key\n        const value: string = String(data[property]);\n        if (this.stringCompare(value, filter.comparand, filter.predicate)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private checkCustomDimFilter(filter: FilterInfo, data: TelemetryData): boolean {\n    const fieldName: string = filter.fieldName.replace(\"CustomDimensions.\", \"\");\n    let value: string | undefined;\n    if (data.CustomDimensions.has(fieldName)) {\n      value = data.CustomDimensions.get(fieldName) as string;\n    } else {\n      return false; // the asked for field is not present in the custom dimensions\n    }\n    return this.stringCompare(value, filter.comparand, filter.predicate);\n  }\n\n  private stringCompare(dataValue: string, comparand: string, predicate: string): boolean {\n    switch (predicate) {\n      case KnownPredicateType.Equal.toString():\n        return dataValue === comparand;\n      case KnownPredicateType.NotEqual.toString():\n        return dataValue !== comparand;\n      case KnownPredicateType.Contains.toString(): {\n        const lowerDataValue = dataValue.toLowerCase();\n        const lowerComparand = comparand.toLowerCase();\n        return lowerDataValue.includes(lowerComparand);\n      }\n      case KnownPredicateType.DoesNotContain.toString(): {\n        const lowerDataValue = dataValue.toLowerCase();\n        const lowerComparand = comparand.toLowerCase();\n        return !lowerDataValue.includes(lowerComparand);\n      }\n      default:\n        return false;\n    }\n  }\n}\n"]}